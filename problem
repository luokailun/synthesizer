



M = ({'_S1': ['p2', 'p1'], 'Int': ['1', '0', '3', '2', '4'], 'Bool': ['True', 'False']}, {'turn(p1)': 'False', 'numStone()': '0', 'turn(p2)': 'True'})

C = !exists(X1:Int)[numStone() > X1]


QAQ: C is actually equivalent to False (C \equiv False);  but we cannot use model M to detect this? Because in M we assume the Int sort only has objects 0-4 and we have M \models C (but negative number will make that false).

SOLVE: (1) add additional predicates: we require that X1>=0 since we only focus on the case natural number
	   (2) add math checking about predicates by expanding the Int domain to 0-10 ??? (give up)



--------------------------------------------------------------------------------------------------------------------------------

too slow and predicate problem

has constructed 


--------------------------------------------------------------------------------------------------------------------------------

too much conjuncts!


1. detect free variables ??

2. first combine one predicate (detect those fails to combine), then use the failure information to guide further combination ??
	
	When filtering a predicate:
	(1) use P model?  No, because even this predicate include the P model, its conjunction may exclude it.
		(when a predicate exclude the P model, so its conjunction do) (So the set of P model will gradually decrease)
	(2) use N model?  Yes, but how to do it??


3. first generate conjuncts of the same length, then generate longer conjuncts??


		# for each sub-conjunct, first divide variables according to different sorts
		sort_vars_dict_list = [__get_sort_vars_dict(subconjunct) for subconjunct in subconjunct_list]
		# get mappings on how to combine variables between two conjuncts
		var_mapping_list = sum([ __get_var_mappings(subconjunct_sort_vars_dict, c, MAX_VAR) \
			for subconjunct_sort_vars_dict in sort_vars_dict_list for c in  basic_conjunct_list],list())


